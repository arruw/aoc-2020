type Input = <INPUT TYPE>;
type Output = <OUTPUT TYPE>;

#[allow(dead_code)]
fn input_generator(input: &str) -> Input {
    todo!()
}

#[allow(dead_code)]
fn solve_part1(input: Input) -> Output {
    todo!()
}

#[allow(dead_code)]
fn solve_part2(input: Input) -> Output {
    todo!()
}

#[cfg(test)]
mod tests {
    use super::{input_generator, solve_part1, solve_part2};
    use crate::read_input;

    const DAY: u32 = <3>;
    const SAMPLE: &str = <SAMPLE>;

    #[test]
    fn test_sample_part1() {
        let solution = solve_part1(input_generator(SAMPLE));

        assert_eq!(-1, solution);
    }

    #[test]
    fn test_sample_part2() {
        let solution = solve_part2(input_generator(SAMPLE));

        assert_eq!(-1, solution);
    }

    #[test]
    fn test_input_part1() {
        let input = read_input(2020, DAY).unwrap();
        let solution = solve_part1(input_generator(&input));

        assert_eq!(-1, solution);
    }

    #[test]
    fn test_input_part2() {
        let input = read_input(2020, DAY).unwrap();
        let solution = solve_part2(input_generator(&input));

        assert_eq!(-1, solution);
    }
}
